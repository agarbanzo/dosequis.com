webpackJsonp([0],{593:function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _tracking = __webpack_require__(11);\n\nvar _tracking2 = _interopRequireDefault(_tracking);\n\nvar _slickCarousel = __webpack_require__(31);\n\nvar _slickCarousel2 = _interopRequireDefault(_slickCarousel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n__webpack_require__(597);\n__webpack_require__(596);\n__webpack_require__(598);\n/*********************\r\n\tadd these lines to file this chunk is used\r\n/*********************/\n__webpack_require__(330);\n\nvar myModule = {\n\n\tmyProperty: \"someValue\",\n\n\tmyConfig: {\n\t\tdates: ['1897', '1920', '1940', '1979', '1983', '1984', '2004', '2011', '2016']\n\t},\n\n\tinit: function init(selector) {\n\t\tthis.$el = $(selector);\n\t\tthis.initSlick();\n\t\tthis.initSlider();\n\t},\n\n\t// a very basic method\n\tinitSlick: function initSlick() {\n\t\tvar _this = this;\n\t\tvar $item = this.$el.find('.item');\n\n\t\t$(\".bottle-items\").slick({\n\t\t\tinfinite: false,\n\t\t\tdots: true,\n\t\t\tcenterMode: true,\n\t\t\tslidesToShow: 5,\n\t\t\tlazyLoad: 'ondemand',\n\t\t\tautoplay: false,\n\n\t\t\tresponsive: [{\n\t\t\t\tbreakpoint: 1024,\n\t\t\t\tsettings: {\n\t\t\t\t\tslidesToShow: 3\n\t\t\t\t}\n\t\t\t}, {\n\n\t\t\t\tbreakpoint: 640,\n\t\t\t\tsettings: {\n\t\t\t\t\tslidesToShow: 1\n\t\t\t\t}\n\t\t\t}]\n\t\t});\n\n\t\t$item.eq(0).addClass('selected');\n\n\t\t$('.bottle-items').on('beforeChange', function (event, slick, currentSlide, nextSlide) {\n\n\t\t\t$('.ui-slider-label').eq(nextSlide).trigger('mousedown.selectPip');\n\n\t\t\t$item.eq(nextSlide).addClass('selected').siblings().removeClass('selected');\n\t\t});\n\n\t\t$('.bottle-items').on('swipe', function (event, slick, direction) {\n\t\t\tvar index = $(event.currentTarget).find('.slick-current').data('slick-index') + 1;\n\t\t\t_tracking2.default.trackEvent({\n\t\t\t\taction: 'swipe',\n\t\t\t\tcategory: \"PackagingEvolution\",\n\t\t\t\tlabel: 'slide-' + _this.myConfig.dates[index]\n\t\t\t});\n\t\t});\n\t},\n\n\tinitSlider: function initSlider() {\n\t\tvar _this = this;\n\t\tvar $item = this.$el.find('.slick-slide');\n\n\t\t$(\".range-slider\")\n\t\t// activate th slider with options\n\t\t.slider({\n\t\t\tmin: 0,\n\t\t\tmax: _this.myConfig.dates.length - 1,\n\t\t\tvalue: 0,\n\t\t\tanimate: 400\n\t\t})\n\t\t// add pips with the labels set to \"months\"\n\t\t.slider(\"pips\", {\n\t\t\trest: \"label\",\n\t\t\tlabels: _this.myConfig.dates\n\t\t})\n\t\t// and whenever the slider changes, lets echo out the month\n\t\t.on(\"slidechange\", function (e, ui) {\n\t\t\t_this.$el.find(\".slick-dots\").find('li').eq(ui.value).trigger('click');\n\n\t\t\t$item.eq(ui.value).addClass('selected').siblings().removeClass('selected');\n\n\t\t\t_tracking2.default.trackEvent({\n\t\t\t\tcategory: \"PackagingEvolution\",\n\t\t\t\tlabel: 'click-' + _this.myConfig.dates[ui.value]\n\t\t\t});\n\t\t});\n\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 768px)\");\n\n\t\tif (isMobile.matches) {\n\t\t\t$(\".range-slider\").draggable();\n\t\t}\n\t}\n\n};\n\nmodule.exports = myModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./dev/scripts/about/range-slide-gallery.js\n// module id = 593\n// module chunks = 0\n\n//# sourceURL=webpack:///./dev/scripts/about/range-slide-gallery.js?")},596:function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(jQuery) {\n\n(function ($) {\n\n    "use strict";\n\n    var extensionMethods = {\n\n        pips: function pips(settings) {\n\n            var slider = this,\n                i,\n                j,\n                p,\n                collection = "",\n                mousedownHandlers,\n                min = slider._valueMin(),\n                max = slider._valueMax(),\n                pips = (max - min) / slider.options.step,\n                $handles = slider.element.find(".ui-slider-handle"),\n                $pips;\n\n            var options = {\n\n                first: "label",\n                /* "label", "pip", false */\n\n                last: "label",\n                /* "label", "pip", false */\n\n                rest: "pip",\n                /* "label", "pip", false */\n\n                labels: false,\n                /* [array], { first: "string", rest: [array], last: "string" }, false */\n\n                prefix: "",\n                /* "", string */\n\n                suffix: "",\n                /* "", string */\n\n                step: pips > 100 ? Math.floor(pips * 0.05) : 1,\n                /* number */\n\n                formatLabel: function formatLabel(value) {\n                    return this.prefix + value + this.suffix;\n                }\n                /* function\n                    must return a value to display in the pip labels */\n\n            };\n\n            if ($.type(settings) === "object" || $.type(settings) === "undefined") {\n\n                $.extend(options, settings);\n                slider.element.data("pips-options", options);\n            } else {\n\n                if (settings === "destroy") {\n\n                    destroy();\n                } else if (settings === "refresh") {\n\n                    slider.element.slider("pips", slider.element.data("pips-options"));\n                }\n\n                return;\n            }\n\n            slider.options.pipStep = Math.abs(Math.round(options.step)) || 1;\n\n            // get rid of all pips that might already exist.\n            slider.element.off(".selectPip").addClass("ui-slider-pips").find(".ui-slider-pip").remove();\n\n            // small object with functions for marking pips as selected.\n\n            var selectPip = {\n\n                single: function single(value) {\n\n                    this.resetClasses();\n\n                    $pips.filter(".ui-slider-pip-" + this.classLabel(value)).addClass("ui-slider-pip-selected");\n\n                    if (slider.options.range) {\n\n                        $pips.each(function (k, v) {\n\n                            var pipVal = $(v).children(".ui-slider-label").data("value");\n\n                            if (slider.options.range === "min" && pipVal < value || slider.options.range === "max" && pipVal > value) {\n\n                                $(v).addClass("ui-slider-pip-inrange");\n                            }\n                        });\n                    }\n                },\n\n                range: function range(values) {\n\n                    this.resetClasses();\n\n                    for (i = 0; i < values.length; i++) {\n\n                        $pips.filter(".ui-slider-pip-" + this.classLabel(values[i])).addClass("ui-slider-pip-selected-" + (i + 1));\n                    }\n\n                    if (slider.options.range) {\n\n                        $pips.each(function (k, v) {\n\n                            var pipVal = $(v).children(".ui-slider-label").data("value");\n\n                            if (pipVal > values[0] && pipVal < values[1]) {\n\n                                $(v).addClass("ui-slider-pip-inrange");\n                            }\n                        });\n                    }\n                },\n\n                classLabel: function classLabel(value) {\n\n                    return value.toString().replace(".", "-");\n                },\n\n                resetClasses: function resetClasses() {\n\n                    var regex = /(^|\\s*)(ui-slider-pip-selected|ui-slider-pip-inrange)(-{1,2}\\d+|\\s|$)/gi;\n\n                    $pips.removeClass(function (index, css) {\n                        return (css.match(regex) || []).join(" ");\n                    });\n                }\n\n            };\n\n            function getClosestHandle(val) {\n\n                var h,\n                    k,\n                    sliderVals,\n                    comparedVals,\n                    closestVal,\n                    tempHandles = [],\n                    closestHandle = 0;\n\n                if (slider.values() && slider.values().length) {\n\n                    // get the current values of the slider handles\n                    sliderVals = slider.values();\n\n                    // find the offset value from the `val` for each\n                    // handle, and store it in a new array\n                    comparedVals = $.map(sliderVals, function (v) {\n                        return Math.abs(v - val);\n                    });\n\n                    // figure out the closest handles to the value\n                    closestVal = Math.min.apply(Math, comparedVals);\n\n                    // if a comparedVal is the closestVal, then\n                    // set the value accordingly, and set the closest handle.\n                    for (h = 0; h < comparedVals.length; h++) {\n                        if (comparedVals[h] === closestVal) {\n                            tempHandles.push(h);\n                        }\n                    }\n\n                    // set the closest handle to the first handle in array,\n                    // just incase we have no _lastChangedValue to compare to.\n                    closestHandle = tempHandles[0];\n\n                    // now we want to find out if any of the closest handles were\n                    // the last changed handle, if so we specify that handle to change\n                    for (k = 0; k < tempHandles.length; k++) {\n                        if (slider._lastChangedValue === tempHandles[k]) {\n                            closestHandle = tempHandles[k];\n                        }\n                    }\n\n                    if (slider.options.range && tempHandles.length === 2) {\n\n                        if (val > sliderVals[1]) {\n\n                            closestHandle = tempHandles[1];\n                        } else if (val < sliderVals[0]) {\n\n                            closestHandle = tempHandles[0];\n                        }\n                    }\n                }\n\n                return closestHandle;\n            }\n\n            function destroy() {\n\n                slider.element.off(".selectPip").on("mousedown.slider", slider.element.data("mousedown-original")).removeClass("ui-slider-pips").find(".ui-slider-pip").remove();\n            }\n\n            // when we click on a label, we want to make sure the\n            // slider\'s handle actually goes to that label!\n            // so we check all the handles and see which one is closest\n            // to the label we clicked. If 2 handles are equidistant then\n            // we move both of them. We also want to trigger focus on the\n            // handle.\n\n            // without this method the label is just treated like a part\n            // of the slider and there\'s no accuracy in the selected value\n\n            function labelClick(label, e) {\n\n                if (slider.option("disabled")) {\n                    return;\n                }\n\n                var val = $(label).data("value"),\n                    indexToChange = getClosestHandle(val);\n\n                if (slider.values() && slider.values().length) {\n\n                    slider.options.values[indexToChange] = slider._trimAlignValue(val);\n                } else {\n\n                    slider.options.value = slider._trimAlignValue(val);\n                }\n\n                slider._refreshValue();\n                slider._change(e, indexToChange);\n            }\n\n            // method for creating a pip. We loop this for creating all\n            // the pips.\n\n            function createPip(which) {\n\n                var label,\n                    percent,\n                    number = which,\n                    classes = "ui-slider-pip",\n                    css = "",\n                    value = slider.value(),\n                    values = slider.values(),\n                    labelValue,\n                    classLabel,\n                    labelIndex;\n\n                if (which === "first") {\n\n                    number = 0;\n                } else if (which === "last") {\n\n                    number = pips;\n                }\n\n                // labelValue is the actual value of the pip based on the min/step\n                labelValue = min + slider.options.step * number;\n\n                // classLabel replaces any decimals with hyphens\n                classLabel = labelValue.toString().replace(".", "-");\n\n                // get the index needed for selecting labels out of the array\n                labelIndex = Math.round((number - min) / options.step);\n\n                // we need to set the human-readable label to either the\n                // corresponding element in the array, or the appropriate\n                // item in the object... or an empty string.\n\n                if ($.type(options.labels) === "array") {\n\n                    label = options.labels[labelIndex] || "";\n                } else if ($.type(options.labels) === "object") {\n\n                    if (which === "first") {\n\n                        // set first label\n                        label = options.labels.first || "";\n                    } else if (which === "last") {\n\n                        // set last label\n                        label = options.labels.last || "";\n                    } else if ($.type(options.labels.rest) === "array") {\n\n                        // set other labels, but our index should start at -1\n                        // because of the first pip.\n                        label = options.labels.rest[labelIndex - 1] || "";\n                    } else {\n\n                        // urrggh, the options must be f**ked, just show nothing.\n                        label = labelValue;\n                    }\n                } else {\n\n                    label = labelValue;\n                }\n\n                if (which === "first") {\n\n                    // first Pip on the Slider\n                    percent = "0%";\n\n                    classes += " ui-slider-pip-first";\n                    classes += options.first === "label" ? " ui-slider-pip-label" : "";\n                    classes += options.first === false ? " ui-slider-pip-hide" : "";\n                } else if (which === "last") {\n\n                    // last Pip on the Slider\n                    percent = "100%";\n\n                    classes += " ui-slider-pip-last";\n                    classes += options.last === "label" ? " ui-slider-pip-label" : "";\n                    classes += options.last === false ? " ui-slider-pip-hide" : "";\n                } else {\n\n                    // all other Pips\n                    percent = (100 / pips * which).toFixed(4) + "%";\n\n                    classes += options.rest === "label" ? " ui-slider-pip-label" : "";\n                    classes += options.rest === false ? " ui-slider-pip-hide" : "";\n                }\n\n                classes += " ui-slider-pip-" + classLabel;\n\n                // add classes for the initial-selected values.\n                if (values && values.length) {\n\n                    for (i = 0; i < values.length; i++) {\n\n                        if (labelValue === values[i]) {\n\n                            classes += " ui-slider-pip-initial-" + (i + 1);\n                            classes += " ui-slider-pip-selected-" + (i + 1);\n                        }\n                    }\n\n                    if (slider.options.range) {\n\n                        if (labelValue > values[0] && labelValue < values[1]) {\n\n                            classes += " ui-slider-pip-inrange";\n                        }\n                    }\n                } else {\n\n                    if (labelValue === value) {\n\n                        classes += " ui-slider-pip-initial";\n                        classes += " ui-slider-pip-selected";\n                    }\n\n                    if (slider.options.range) {\n\n                        if (slider.options.range === "min" && labelValue < value || slider.options.range === "max" && labelValue > value) {\n\n                            classes += " ui-slider-pip-inrange";\n                        }\n                    }\n                }\n\n                css = slider.options.orientation === "horizontal" ? "left: " + percent : "bottom: " + percent;\n\n                // add this current pip to the collection\n                return "<span class=\\"" + classes + "\\" style=\\"" + css + "\\">" + "<span class=\\"ui-slider-line\\"></span>" + "<span class=\\"ui-slider-label\\" data-value=\\"" + labelValue + "\\">" + options.formatLabel(label) + "</span>" + "</span>";\n            }\n\n            // create our first pip\n            collection += createPip("first");\n\n            // for every stop in the slider where we need a pip; create one.\n            for (p = slider.options.pipStep; p < pips; p += slider.options.pipStep) {\n                collection += createPip(p);\n            }\n\n            // create our last pip\n            collection += createPip("last");\n\n            // append the collection of pips.\n            slider.element.append(collection);\n\n            // store the pips for setting classes later.\n            $pips = slider.element.find(".ui-slider-pip");\n\n            // store the mousedown handlers for later, just in case we reset\n            // the slider, the handler would be lost!\n\n            if ($._data(slider.element.get(0), "events").mousedown && $._data(slider.element.get(0), "events").mousedown.length) {\n\n                mousedownHandlers = $._data(slider.element.get(0), "events").mousedown;\n            } else {\n\n                mousedownHandlers = slider.element.data("mousedown-handlers");\n            }\n\n            slider.element.data("mousedown-handlers", mousedownHandlers.slice());\n\n            // loop through all the mousedown handlers on the slider,\n            // and store the original namespaced (.slider) event handler so\n            // we can trigger it later.\n            for (j = 0; j < mousedownHandlers.length; j++) {\n                if (mousedownHandlers[j].namespace === "slider") {\n                    slider.element.data("mousedown-original", mousedownHandlers[j].handler);\n                }\n            }\n\n            // unbind the mousedown.slider event, because it interferes with\n            // the labelClick() method (stops smooth animation), and decide\n            // if we want to trigger the original event based on which element\n            // was clicked.\n            slider.element.off("mousedown.slider").on("mousedown.selectPip", function (e) {\n\n                var $target = $(e.target),\n                    closest = getClosestHandle($target.data("value")),\n                    $handle = $handles.eq(closest);\n\n                $handle.addClass("ui-state-active");\n\n                if ($target.is(".ui-slider-label")) {\n\n                    labelClick($target, e);\n\n                    slider.element.one("mouseup.selectPip", function () {\n\n                        $handle.removeClass("ui-state-active").focus();\n                    });\n                } else {\n\n                    var originalMousedown = slider.element.data("mousedown-original");\n                    originalMousedown(e);\n                }\n            });\n\n            slider.element.on("slide.selectPip slidechange.selectPip", function (e, ui) {\n\n                var $slider = $(this),\n                    value = $slider.slider("value"),\n                    values = $slider.slider("values");\n\n                if (ui) {\n                    value = ui.value;\n                    values = ui.values;\n                }\n\n                if (slider.values() && slider.values().length) {\n\n                    selectPip.range(values);\n                } else {\n\n                    selectPip.single(value);\n                }\n            });\n        },\n\n        // floats\n\n        float: function float(settings) {\n\n            var i,\n                slider = this,\n                min = slider._valueMin(),\n                max = slider._valueMax(),\n                value = slider._value(),\n                values = slider._values(),\n                tipValues = [],\n                $handles = slider.element.find(".ui-slider-handle");\n\n            var options = {\n\n                handle: true,\n                /* false */\n\n                pips: false,\n                /* true */\n\n                labels: false,\n                /* [array], { first: "string", rest: [array], last: "string" }, false */\n\n                prefix: "",\n                /* "", string */\n\n                suffix: "",\n                /* "", string */\n\n                event: "slidechange slide",\n                /* "slidechange", "slide", "slidechange slide" */\n\n                formatLabel: function formatLabel(value) {\n                    return this.prefix + value + this.suffix;\n                }\n                /* function\n                    must return a value to display in the floats */\n\n            };\n\n            if ($.type(settings) === "object" || $.type(settings) === "undefined") {\n\n                $.extend(options, settings);\n                slider.element.data("float-options", options);\n            } else {\n\n                if (settings === "destroy") {\n\n                    destroy();\n                } else if (settings === "refresh") {\n\n                    slider.element.slider("float", slider.element.data("float-options"));\n                }\n\n                return;\n            }\n\n            if (value < min) {\n                value = min;\n            }\n\n            if (value > max) {\n                value = max;\n            }\n\n            if (values && values.length) {\n\n                for (i = 0; i < values.length; i++) {\n\n                    if (values[i] < min) {\n                        values[i] = min;\n                    }\n\n                    if (values[i] > max) {\n                        values[i] = max;\n                    }\n                }\n            }\n\n            // add a class for the CSS\n            slider.element.addClass("ui-slider-float").find(".ui-slider-tip, .ui-slider-tip-label").remove();\n\n            function destroy() {\n\n                slider.element.off(".sliderFloat").removeClass("ui-slider-float").find(".ui-slider-tip, .ui-slider-tip-label").remove();\n            }\n\n            function getPipLabels(values) {\n\n                // when checking the array we need to divide\n                // by the step option, so we store those values here.\n\n                var vals = [],\n                    steppedVals = $.map(values, function (v) {\n                    return Math.ceil((v - min) / slider.options.step);\n                });\n\n                // now we just get the values we need to return\n                // by looping through the values array and assigning the\n                // label if it exists.\n\n                if ($.type(options.labels) === "array") {\n\n                    for (i = 0; i < values.length; i++) {\n\n                        vals[i] = options.labels[steppedVals[i]] || values[i];\n                    }\n                } else if ($.type(options.labels) === "object") {\n\n                    for (i = 0; i < values.length; i++) {\n\n                        if (values[i] === min) {\n\n                            vals[i] = options.labels.first || min;\n                        } else if (values[i] === max) {\n\n                            vals[i] = options.labels.last || max;\n                        } else if ($.type(options.labels.rest) === "array") {\n\n                            vals[i] = options.labels.rest[steppedVals[i] - 1] || values[i];\n                        } else {\n\n                            vals[i] = values[i];\n                        }\n                    }\n                } else {\n\n                    for (i = 0; i < values.length; i++) {\n\n                        vals[i] = values[i];\n                    }\n                }\n\n                return vals;\n            }\n\n            // apply handle tip if settings allows.\n            if (options.handle) {\n\n                // we need to set the human-readable label to either the\n                // corresponding element in the array, or the appropriate\n                // item in the object... or an empty string.\n\n                tipValues = slider.values() && slider.values().length ? getPipLabels(values) : getPipLabels([value]);\n\n                for (i = 0; i < tipValues.length; i++) {\n\n                    $handles.eq(i).append($("<span class=\\"ui-slider-tip\\">" + options.formatLabel(tipValues[i]) + "</span>"));\n                }\n            }\n\n            if (options.pips) {\n\n                // if this slider also has pip-labels, we make those into tips, too.\n                slider.element.find(".ui-slider-label").each(function (k, v) {\n\n                    var $this = $(v),\n                        val = [$this.data("value")],\n                        label,\n                        $tip;\n\n                    label = options.formatLabel(getPipLabels(val)[0]);\n\n                    // create a tip element\n                    $tip = $("<span class=\\"ui-slider-tip-label\\">" + label + "</span>").insertAfter($this);\n                });\n            }\n\n            // check that the event option is actually valid against our\n            // own list of the slider\'s events.\n            if (options.event !== "slide" && options.event !== "slidechange" && options.event !== "slide slidechange" && options.event !== "slidechange slide") {\n\n                options.event = "slidechange slide";\n            }\n\n            // when slider changes, update handle tip label.\n            slider.element.off(".sliderFloat").on(options.event + ".sliderFloat", function (e, ui) {\n\n                var uiValue = $.type(ui.value) === "array" ? ui.value : [ui.value],\n                    val = options.formatLabel(getPipLabels(uiValue)[0]);\n\n                $(ui.handle).find(".ui-slider-tip").html(val);\n            });\n        }\n\n    };\n\n    $.extend(true, $.ui.slider.prototype, extensionMethods);\n})(jQuery);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./dev/scripts/vendor/jquery-ui-slider-pips.js\n// module id = 596\n// module chunks = 0\n\n//# sourceURL=webpack:///./dev/scripts/vendor/jquery-ui-slider-pips.js?')},597:function(module,exports,__webpack_require__){"use strict";eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n/*! jQuery UI - v1.12.1 - 2016-09-25\n* http://jqueryui.com\n* Includes: widget.js, data.js, keycode.js, scroll-parent.js, widgets/draggable.js, widgets/mouse.js, widgets/slider.js\n* Copyright jQuery Foundation and other contributors; Licensed MIT */\n\n(function (t) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : t(jQuery);\n})(function (t) {\n  t.ui = t.ui || {}, t.ui.version = "1.12.1";var e = 0,\n      i = Array.prototype.slice;t.cleanData = function (e) {\n    return function (i) {\n      var s, n, o;for (o = 0; null != (n = i[o]); o++) {\n        try {\n          s = t._data(n, "events"), s && s.remove && t(n).triggerHandler("remove");\n        } catch (a) {}\n      }e(i);\n    };\n  }(t.cleanData), t.widget = function (e, i, s) {\n    var n,\n        o,\n        a,\n        r = {},\n        l = e.split(".")[0];e = e.split(".")[1];var h = l + "-" + e;return s || (s = i, i = t.Widget), t.isArray(s) && (s = t.extend.apply(null, [{}].concat(s))), t.expr[":"][h.toLowerCase()] = function (e) {\n      return !!t.data(e, h);\n    }, t[l] = t[l] || {}, n = t[l][e], o = t[l][e] = function (t, e) {\n      return this._createWidget ? (arguments.length && this._createWidget(t, e), void 0) : new o(t, e);\n    }, t.extend(o, n, { version: s.version, _proto: t.extend({}, s), _childConstructors: [] }), a = new i(), a.options = t.widget.extend({}, a.options), t.each(s, function (e, s) {\n      return t.isFunction(s) ? (r[e] = function () {\n        function t() {\n          return i.prototype[e].apply(this, arguments);\n        }function n(t) {\n          return i.prototype[e].apply(this, t);\n        }return function () {\n          var e,\n              i = this._super,\n              o = this._superApply;return this._super = t, this._superApply = n, e = s.apply(this, arguments), this._super = i, this._superApply = o, e;\n        };\n      }(), void 0) : (r[e] = s, void 0);\n    }), o.prototype = t.widget.extend(a, { widgetEventPrefix: n ? a.widgetEventPrefix || e : e }, r, { constructor: o, namespace: l, widgetName: e, widgetFullName: h }), n ? (t.each(n._childConstructors, function (e, i) {\n      var s = i.prototype;t.widget(s.namespace + "." + s.widgetName, o, i._proto);\n    }), delete n._childConstructors) : i._childConstructors.push(o), t.widget.bridge(e, o), o;\n  }, t.widget.extend = function (e) {\n    for (var s, n, o = i.call(arguments, 1), a = 0, r = o.length; r > a; a++) {\n      for (s in o[a]) {\n        n = o[a][s], o[a].hasOwnProperty(s) && void 0 !== n && (e[s] = t.isPlainObject(n) ? t.isPlainObject(e[s]) ? t.widget.extend({}, e[s], n) : t.widget.extend({}, n) : n);\n      }\n    }return e;\n  }, t.widget.bridge = function (e, s) {\n    var n = s.prototype.widgetFullName || e;t.fn[e] = function (o) {\n      var a = "string" == typeof o,\n          r = i.call(arguments, 1),\n          l = this;return a ? this.length || "instance" !== o ? this.each(function () {\n        var i,\n            s = t.data(this, n);return "instance" === o ? (l = s, !1) : s ? t.isFunction(s[o]) && "_" !== o.charAt(0) ? (i = s[o].apply(s, r), i !== s && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0) : t.error("no such method \'" + o + "\' for " + e + " widget instance") : t.error("cannot call methods on " + e + " prior to initialization; " + "attempted to call method \'" + o + "\'");\n      }) : l = void 0 : (r.length && (o = t.widget.extend.apply(null, [o].concat(r))), this.each(function () {\n        var e = t.data(this, n);e ? (e.option(o || {}), e._init && e._init()) : t.data(this, n, new s(o, this));\n      })), l;\n    };\n  }, t.Widget = function () {}, t.Widget._childConstructors = [], t.Widget.prototype = { widgetName: "widget", widgetEventPrefix: "", defaultElement: "<div>", options: { classes: {}, disabled: !1, create: null }, _createWidget: function _createWidget(i, s) {\n      s = t(s || this.defaultElement || this)[0], this.element = t(s), this.uuid = e++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = t(), this.hoverable = t(), this.focusable = t(), this.classesElementLookup = {}, s !== this && (t.data(s, this.widgetFullName, this), this._on(!0, this.element, { remove: function remove(t) {\n          t.target === s && this.destroy();\n        } }), this.document = t(s.style ? s.ownerDocument : s.document || s), this.window = t(this.document[0].defaultView || this.document[0].parentWindow)), this.options = t.widget.extend({}, this.options, this._getCreateOptions(), i), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init();\n    }, _getCreateOptions: function _getCreateOptions() {\n      return {};\n    }, _getCreateEventData: t.noop, _create: t.noop, _init: t.noop, destroy: function destroy() {\n      var e = this;this._destroy(), t.each(this.classesElementLookup, function (t, i) {\n        e._removeClass(i, t);\n      }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace);\n    }, _destroy: t.noop, widget: function widget() {\n      return this.element;\n    }, option: function option(e, i) {\n      var s,\n          n,\n          o,\n          a = e;if (0 === arguments.length) return t.widget.extend({}, this.options);if ("string" == typeof e) if (a = {}, s = e.split("."), e = s.shift(), s.length) {\n        for (n = a[e] = t.widget.extend({}, this.options[e]), o = 0; s.length - 1 > o; o++) {\n          n[s[o]] = n[s[o]] || {}, n = n[s[o]];\n        }if (e = s.pop(), 1 === arguments.length) return void 0 === n[e] ? null : n[e];n[e] = i;\n      } else {\n        if (1 === arguments.length) return void 0 === this.options[e] ? null : this.options[e];a[e] = i;\n      }return this._setOptions(a), this;\n    }, _setOptions: function _setOptions(t) {\n      var e;for (e in t) {\n        this._setOption(e, t[e]);\n      }return this;\n    }, _setOption: function _setOption(t, e) {\n      return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this;\n    }, _setOptionClasses: function _setOptionClasses(e) {\n      var i, s, n;for (i in e) {\n        n = this.classesElementLookup[i], e[i] !== this.options.classes[i] && n && n.length && (s = t(n.get()), this._removeClass(n, i), s.addClass(this._classes({ element: s, keys: i, classes: e, add: !0 })));\n      }\n    }, _setOptionDisabled: function _setOptionDisabled(t) {\n      this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"));\n    }, enable: function enable() {\n      return this._setOptions({ disabled: !1 });\n    }, disable: function disable() {\n      return this._setOptions({ disabled: !0 });\n    }, _classes: function _classes(e) {\n      function i(i, o) {\n        var a, r;for (r = 0; i.length > r; r++) {\n          a = n.classesElementLookup[i[r]] || t(), a = e.add ? t(t.unique(a.get().concat(e.element.get()))) : t(a.not(e.element).get()), n.classesElementLookup[i[r]] = a, s.push(i[r]), o && e.classes[i[r]] && s.push(e.classes[i[r]]);\n        }\n      }var s = [],\n          n = this;return e = t.extend({ element: this.element, classes: this.options.classes || {} }, e), this._on(e.element, { remove: "_untrackClassesElement" }), e.keys && i(e.keys.match(/\\S+/g) || [], !0), e.extra && i(e.extra.match(/\\S+/g) || []), s.join(" ");\n    }, _untrackClassesElement: function _untrackClassesElement(e) {\n      var i = this;t.each(i.classesElementLookup, function (s, n) {\n        -1 !== t.inArray(e.target, n) && (i.classesElementLookup[s] = t(n.not(e.target).get()));\n      });\n    }, _removeClass: function _removeClass(t, e, i) {\n      return this._toggleClass(t, e, i, !1);\n    }, _addClass: function _addClass(t, e, i) {\n      return this._toggleClass(t, e, i, !0);\n    }, _toggleClass: function _toggleClass(t, e, i, s) {\n      s = "boolean" == typeof s ? s : i;var n = "string" == typeof t || null === t,\n          o = { extra: n ? e : i, keys: n ? t : e, element: n ? this.element : t, add: s };return o.element.toggleClass(this._classes(o), s), this;\n    }, _on: function _on(e, i, s) {\n      var n,\n          o = this;"boolean" != typeof e && (s = i, i = e, e = !1), s ? (i = n = t(i), this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), t.each(s, function (s, a) {\n        function r() {\n          return e || o.options.disabled !== !0 && !t(this).hasClass("ui-state-disabled") ? ("string" == typeof a ? o[a] : a).apply(o, arguments) : void 0;\n        }"string" != typeof a && (r.guid = a.guid = a.guid || r.guid || t.guid++);var l = s.match(/^([\\w:-]*)\\s*(.*)$/),\n            h = l[1] + o.eventNamespace,\n            c = l[2];c ? n.on(h, c, r) : i.on(h, r);\n      });\n    }, _off: function _off(e, i) {\n      i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, e.off(i).off(i), this.bindings = t(this.bindings.not(e).get()), this.focusable = t(this.focusable.not(e).get()), this.hoverable = t(this.hoverable.not(e).get());\n    }, _delay: function _delay(t, e) {\n      function i() {\n        return ("string" == typeof t ? s[t] : t).apply(s, arguments);\n      }var s = this;return setTimeout(i, e || 0);\n    }, _hoverable: function _hoverable(e) {\n      this.hoverable = this.hoverable.add(e), this._on(e, { mouseenter: function mouseenter(e) {\n          this._addClass(t(e.currentTarget), null, "ui-state-hover");\n        }, mouseleave: function mouseleave(e) {\n          this._removeClass(t(e.currentTarget), null, "ui-state-hover");\n        } });\n    }, _focusable: function _focusable(e) {\n      this.focusable = this.focusable.add(e), this._on(e, { focusin: function focusin(e) {\n          this._addClass(t(e.currentTarget), null, "ui-state-focus");\n        }, focusout: function focusout(e) {\n          this._removeClass(t(e.currentTarget), null, "ui-state-focus");\n        } });\n    }, _trigger: function _trigger(e, i, s) {\n      var n,\n          o,\n          a = this.options[e];if (s = s || {}, i = t.Event(i), i.type = (e === this.widgetEventPrefix ? e : this.widgetEventPrefix + e).toLowerCase(), i.target = this.element[0], o = i.originalEvent) for (n in o) {\n        n in i || (i[n] = o[n]);\n      }return this.element.trigger(i, s), !(t.isFunction(a) && a.apply(this.element[0], [i].concat(s)) === !1 || i.isDefaultPrevented());\n    } }, t.each({ show: "fadeIn", hide: "fadeOut" }, function (e, i) {\n    t.Widget.prototype["_" + e] = function (s, n, o) {\n      "string" == typeof n && (n = { effect: n });var a,\n          r = n ? n === !0 || "number" == typeof n ? i : n.effect || i : e;n = n || {}, "number" == typeof n && (n = { duration: n }), a = !t.isEmptyObject(n), n.complete = o, n.delay && s.delay(n.delay), a && t.effects && t.effects.effect[r] ? s[e](n) : r !== e && s[r] ? s[r](n.duration, n.easing, o) : s.queue(function (i) {\n        t(this)[e](), o && o.call(s[0]), i();\n      });\n    };\n  }), t.widget, t.extend(t.expr[":"], { data: t.expr.createPseudo ? t.expr.createPseudo(function (e) {\n      return function (i) {\n        return !!t.data(i, e);\n      };\n    }) : function (e, i, s) {\n      return !!t.data(e, s[3]);\n    } }), t.ui.keyCode = { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 }, t.fn.scrollParent = function (e) {\n    var i = this.css("position"),\n        s = "absolute" === i,\n        n = e ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\n        o = this.parents().filter(function () {\n      var e = t(this);return s && "static" === e.css("position") ? !1 : n.test(e.css("overflow") + e.css("overflow-y") + e.css("overflow-x"));\n    }).eq(0);return "fixed" !== i && o.length ? o : t(this[0].ownerDocument || document);\n  }, t.ui.ie = !!/msie [\\w.]+/.exec(navigator.userAgent.toLowerCase());var s = !1;t(document).on("mouseup", function () {\n    s = !1;\n  }), t.widget("ui.mouse", { version: "1.12.1", options: { cancel: "input, textarea, button, select, option", distance: 1, delay: 0 }, _mouseInit: function _mouseInit() {\n      var e = this;this.element.on("mousedown." + this.widgetName, function (t) {\n        return e._mouseDown(t);\n      }).on("click." + this.widgetName, function (i) {\n        return !0 === t.data(i.target, e.widgetName + ".preventClickEvent") ? (t.removeData(i.target, e.widgetName + ".preventClickEvent"), i.stopImmediatePropagation(), !1) : void 0;\n      }), this.started = !1;\n    }, _mouseDestroy: function _mouseDestroy() {\n      this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);\n    }, _mouseDown: function _mouseDown(e) {\n      if (!s) {\n        this._mouseMoved = !1, this._mouseStarted && this._mouseUp(e), this._mouseDownEvent = e;var i = this,\n            n = 1 === e.which,\n            o = "string" == typeof this.options.cancel && e.target.nodeName ? t(e.target).closest(this.options.cancel).length : !1;return n && !o && this._mouseCapture(e) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {\n          i.mouseDelayMet = !0;\n        }, this.options.delay)), this._mouseDistanceMet(e) && this._mouseDelayMet(e) && (this._mouseStarted = this._mouseStart(e) !== !1, !this._mouseStarted) ? (e.preventDefault(), !0) : (!0 === t.data(e.target, this.widgetName + ".preventClickEvent") && t.removeData(e.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (t) {\n          return i._mouseMove(t);\n        }, this._mouseUpDelegate = function (t) {\n          return i._mouseUp(t);\n        }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), e.preventDefault(), s = !0, !0)) : !0;\n      }\n    }, _mouseMove: function _mouseMove(e) {\n      if (this._mouseMoved) {\n        if (t.ui.ie && (!document.documentMode || 9 > document.documentMode) && !e.button) return this._mouseUp(e);if (!e.which) if (e.originalEvent.altKey || e.originalEvent.ctrlKey || e.originalEvent.metaKey || e.originalEvent.shiftKey) this.ignoreMissingWhich = !0;else if (!this.ignoreMissingWhich) return this._mouseUp(e);\n      }return (e.which || e.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(e), e.preventDefault()) : (this._mouseDistanceMet(e) && this._mouseDelayMet(e) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, e) !== !1, this._mouseStarted ? this._mouseDrag(e) : this._mouseUp(e)), !this._mouseStarted);\n    }, _mouseUp: function _mouseUp(e) {\n      this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, e.target === this._mouseDownEvent.target && t.data(e.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(e)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, s = !1, e.preventDefault();\n    }, _mouseDistanceMet: function _mouseDistanceMet(t) {\n      return Math.max(Math.abs(this._mouseDownEvent.pageX - t.pageX), Math.abs(this._mouseDownEvent.pageY - t.pageY)) >= this.options.distance;\n    }, _mouseDelayMet: function _mouseDelayMet() {\n      return this.mouseDelayMet;\n    }, _mouseStart: function _mouseStart() {}, _mouseDrag: function _mouseDrag() {}, _mouseStop: function _mouseStop() {}, _mouseCapture: function _mouseCapture() {\n      return !0;\n    } }), t.ui.plugin = { add: function add(e, i, s) {\n      var n,\n          o = t.ui[e].prototype;for (n in s) {\n        o.plugins[n] = o.plugins[n] || [], o.plugins[n].push([i, s[n]]);\n      }\n    }, call: function call(t, e, i, s) {\n      var n,\n          o = t.plugins[e];if (o && (s || t.element[0].parentNode && 11 !== t.element[0].parentNode.nodeType)) for (n = 0; o.length > n; n++) {\n        t.options[o[n][0]] && o[n][1].apply(t.element, i);\n      }\n    } }, t.ui.safeActiveElement = function (t) {\n    var e;try {\n      e = t.activeElement;\n    } catch (i) {\n      e = t.body;\n    }return e || (e = t.body), e.nodeName || (e = t.body), e;\n  }, t.ui.safeBlur = function (e) {\n    e && "body" !== e.nodeName.toLowerCase() && t(e).trigger("blur");\n  }, t.widget("ui.draggable", t.ui.mouse, { version: "1.12.1", widgetEventPrefix: "drag", options: { addClasses: !0, appendTo: "parent", axis: !1, connectToSortable: !1, containment: !1, cursor: "auto", cursorAt: !1, grid: !1, handle: !1, helper: "original", iframeFix: !1, opacity: !1, refreshPositions: !1, revert: !1, revertDuration: 500, scope: "default", scroll: !0, scrollSensitivity: 20, scrollSpeed: 20, snap: !1, snapMode: "both", snapTolerance: 20, stack: !1, zIndex: !1, drag: null, start: null, stop: null }, _create: function _create() {\n      "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this._addClass("ui-draggable"), this._setHandleClassName(), this._mouseInit();\n    }, _setOption: function _setOption(t, e) {\n      this._super(t, e), "handle" === t && (this._removeHandleClassName(), this._setHandleClassName());\n    }, _destroy: function _destroy() {\n      return (this.helper || this.element).is(".ui-draggable-dragging") ? (this.destroyOnClear = !0, void 0) : (this._removeHandleClassName(), this._mouseDestroy(), void 0);\n    }, _mouseCapture: function _mouseCapture(e) {\n      var i = this.options;return this.helper || i.disabled || t(e.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(e), this.handle ? (this._blurActiveElement(e), this._blockFrames(i.iframeFix === !0 ? "iframe" : i.iframeFix), !0) : !1);\n    }, _blockFrames: function _blockFrames(e) {\n      this.iframeBlocks = this.document.find(e).map(function () {\n        var e = t(this);return t("<div>").css("position", "absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0];\n      });\n    }, _unblockFrames: function _unblockFrames() {\n      this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);\n    }, _blurActiveElement: function _blurActiveElement(e) {\n      var i = t.ui.safeActiveElement(this.document[0]),\n          s = t(e.target);s.closest(i).length || t.ui.safeBlur(i);\n    }, _mouseStart: function _mouseStart(e) {\n      var i = this.options;return this.helper = this._createHelper(e), this._addClass(this.helper, "ui-draggable-dragging"), this._cacheHelperProportions(), t.ui.ddmanager && (t.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = this.helper.parents().filter(function () {\n        return "fixed" === t(this).css("position");\n      }).length > 0, this.positionAbs = this.element.offset(), this._refreshOffsets(e), this.originalPosition = this.position = this._generatePosition(e, !1), this.originalPageX = e.pageX, this.originalPageY = e.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt), this._setContainment(), this._trigger("start", e) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), t.ui.ddmanager && !i.dropBehaviour && t.ui.ddmanager.prepareOffsets(this, e), this._mouseDrag(e, !0), t.ui.ddmanager && t.ui.ddmanager.dragStart(this, e), !0);\n    }, _refreshOffsets: function _refreshOffsets(t) {\n      this.offset = { top: this.positionAbs.top - this.margins.top, left: this.positionAbs.left - this.margins.left, scroll: !1, parent: this._getParentOffset(), relative: this._getRelativeOffset() }, this.offset.click = { left: t.pageX - this.offset.left, top: t.pageY - this.offset.top };\n    }, _mouseDrag: function _mouseDrag(e, i) {\n      if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(e, !0), this.positionAbs = this._convertPositionTo("absolute"), !i) {\n        var s = this._uiHash();if (this._trigger("drag", e, s) === !1) return this._mouseUp(new t.Event("mouseup", e)), !1;this.position = s.position;\n      }return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", t.ui.ddmanager && t.ui.ddmanager.drag(this, e), !1;\n    }, _mouseStop: function _mouseStop(e) {\n      var i = this,\n          s = !1;return t.ui.ddmanager && !this.options.dropBehaviour && (s = t.ui.ddmanager.drop(this, e)), this.dropped && (s = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !s || "valid" === this.options.revert && s || this.options.revert === !0 || t.isFunction(this.options.revert) && this.options.revert.call(this.element, s) ? t(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {\n        i._trigger("stop", e) !== !1 && i._clear();\n      }) : this._trigger("stop", e) !== !1 && this._clear(), !1;\n    }, _mouseUp: function _mouseUp(e) {\n      return this._unblockFrames(), t.ui.ddmanager && t.ui.ddmanager.dragStop(this, e), this.handleElement.is(e.target) && this.element.trigger("focus"), t.ui.mouse.prototype._mouseUp.call(this, e);\n    }, cancel: function cancel() {\n      return this.helper.is(".ui-draggable-dragging") ? this._mouseUp(new t.Event("mouseup", { target: this.element[0] })) : this._clear(), this;\n    }, _getHandle: function _getHandle(e) {\n      return this.options.handle ? !!t(e.target).closest(this.element.find(this.options.handle)).length : !0;\n    }, _setHandleClassName: function _setHandleClassName() {\n      this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this._addClass(this.handleElement, "ui-draggable-handle");\n    }, _removeHandleClassName: function _removeHandleClassName() {\n      this._removeClass(this.handleElement, "ui-draggable-handle");\n    }, _createHelper: function _createHelper(e) {\n      var i = this.options,\n          s = t.isFunction(i.helper),\n          n = s ? t(i.helper.apply(this.element[0], [e])) : "clone" === i.helper ? this.element.clone().removeAttr("id") : this.element;return n.parents("body").length || n.appendTo("parent" === i.appendTo ? this.element[0].parentNode : i.appendTo), s && n[0] === this.element[0] && this._setPositionRelative(), n[0] === this.element[0] || /(fixed|absolute)/.test(n.css("position")) || n.css("position", "absolute"), n;\n    }, _setPositionRelative: function _setPositionRelative() {\n      /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative");\n    }, _adjustOffsetFromHelper: function _adjustOffsetFromHelper(e) {\n      "string" == typeof e && (e = e.split(" ")), t.isArray(e) && (e = { left: +e[0], top: +e[1] || 0 }), "left" in e && (this.offset.click.left = e.left + this.margins.left), "right" in e && (this.offset.click.left = this.helperProportions.width - e.right + this.margins.left), "top" in e && (this.offset.click.top = e.top + this.margins.top), "bottom" in e && (this.offset.click.top = this.helperProportions.height - e.bottom + this.margins.top);\n    }, _isRootNode: function _isRootNode(t) {\n      return (/(html|body)/i.test(t.tagName) || t === this.document[0]\n      );\n    }, _getParentOffset: function _getParentOffset() {\n      var e = this.offsetParent.offset(),\n          i = this.document[0];return "absolute" === this.cssPosition && this.scrollParent[0] !== i && t.contains(this.scrollParent[0], this.offsetParent[0]) && (e.left += this.scrollParent.scrollLeft(), e.top += this.scrollParent.scrollTop()), this._isRootNode(this.offsetParent[0]) && (e = { top: 0, left: 0 }), { top: e.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: e.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0) };\n    }, _getRelativeOffset: function _getRelativeOffset() {\n      if ("relative" !== this.cssPosition) return { top: 0, left: 0 };var t = this.element.position(),\n          e = this._isRootNode(this.scrollParent[0]);return { top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + (e ? 0 : this.scrollParent.scrollTop()), left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + (e ? 0 : this.scrollParent.scrollLeft()) };\n    }, _cacheMargins: function _cacheMargins() {\n      this.margins = { left: parseInt(this.element.css("marginLeft"), 10) || 0, top: parseInt(this.element.css("marginTop"), 10) || 0, right: parseInt(this.element.css("marginRight"), 10) || 0, bottom: parseInt(this.element.css("marginBottom"), 10) || 0 };\n    }, _cacheHelperProportions: function _cacheHelperProportions() {\n      this.helperProportions = { width: this.helper.outerWidth(), height: this.helper.outerHeight() };\n    }, _setContainment: function _setContainment() {\n      var e,\n          i,\n          s,\n          n = this.options,\n          o = this.document[0];return this.relativeContainer = null, n.containment ? "window" === n.containment ? (this.containment = [t(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, t(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, t(window).scrollLeft() + t(window).width() - this.helperProportions.width - this.margins.left, t(window).scrollTop() + (t(window).height() || o.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top], void 0) : "document" === n.containment ? (this.containment = [0, 0, t(o).width() - this.helperProportions.width - this.margins.left, (t(o).height() || o.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top], void 0) : n.containment.constructor === Array ? (this.containment = n.containment, void 0) : ("parent" === n.containment && (n.containment = this.helper[0].parentNode), i = t(n.containment), s = i[0], s && (e = /(scroll|auto)/.test(i.css("overflow")), this.containment = [(parseInt(i.css("borderLeftWidth"), 10) || 0) + (parseInt(i.css("paddingLeft"), 10) || 0), (parseInt(i.css("borderTopWidth"), 10) || 0) + (parseInt(i.css("paddingTop"), 10) || 0), (e ? Math.max(s.scrollWidth, s.offsetWidth) : s.offsetWidth) - (parseInt(i.css("borderRightWidth"), 10) || 0) - (parseInt(i.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (e ? Math.max(s.scrollHeight, s.offsetHeight) : s.offsetHeight) - (parseInt(i.css("borderBottomWidth"), 10) || 0) - (parseInt(i.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = i), void 0) : (this.containment = null, void 0);\n    }, _convertPositionTo: function _convertPositionTo(t, e) {\n      e || (e = this.position);var i = "absolute" === t ? 1 : -1,\n          s = this._isRootNode(this.scrollParent[0]);return { top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : s ? 0 : this.offset.scroll.top) * i, left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : s ? 0 : this.offset.scroll.left) * i };\n    }, _generatePosition: function _generatePosition(t, e) {\n      var i,\n          s,\n          n,\n          o,\n          a = this.options,\n          r = this._isRootNode(this.scrollParent[0]),\n          l = t.pageX,\n          h = t.pageY;return r && this.offset.scroll || (this.offset.scroll = { top: this.scrollParent.scrollTop(), left: this.scrollParent.scrollLeft() }), e && (this.containment && (this.relativeContainer ? (s = this.relativeContainer.offset(), i = [this.containment[0] + s.left, this.containment[1] + s.top, this.containment[2] + s.left, this.containment[3] + s.top]) : i = this.containment, t.pageX - this.offset.click.left < i[0] && (l = i[0] + this.offset.click.left), t.pageY - this.offset.click.top < i[1] && (h = i[1] + this.offset.click.top), t.pageX - this.offset.click.left > i[2] && (l = i[2] + this.offset.click.left), t.pageY - this.offset.click.top > i[3] && (h = i[3] + this.offset.click.top)), a.grid && (n = a.grid[1] ? this.originalPageY + Math.round((h - this.originalPageY) / a.grid[1]) * a.grid[1] : this.originalPageY, h = i ? n - this.offset.click.top >= i[1] || n - this.offset.click.top > i[3] ? n : n - this.offset.click.top >= i[1] ? n - a.grid[1] : n + a.grid[1] : n, o = a.grid[0] ? this.originalPageX + Math.round((l - this.originalPageX) / a.grid[0]) * a.grid[0] : this.originalPageX, l = i ? o - this.offset.click.left >= i[0] || o - this.offset.click.left > i[2] ? o : o - this.offset.click.left >= i[0] ? o - a.grid[0] : o + a.grid[0] : o), "y" === a.axis && (l = this.originalPageX), "x" === a.axis && (h = this.originalPageY)), { top: h - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : r ? 0 : this.offset.scroll.top), left: l - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : r ? 0 : this.offset.scroll.left) };\n    }, _clear: function _clear() {\n      this._removeClass(this.helper, "ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy();\n    }, _trigger: function _trigger(e, i, s) {\n      return s = s || this._uiHash(), t.ui.plugin.call(this, e, [i, s, this], !0), /^(drag|start|stop)/.test(e) && (this.positionAbs = this._convertPositionTo("absolute"), s.offset = this.positionAbs), t.Widget.prototype._trigger.call(this, e, i, s);\n    }, plugins: {}, _uiHash: function _uiHash() {\n      return { helper: this.helper, position: this.position, originalPosition: this.originalPosition, offset: this.positionAbs };\n    } }), t.ui.plugin.add("draggable", "connectToSortable", { start: function start(e, i, s) {\n      var n = t.extend({}, i, { item: s.element });s.sortables = [], t(s.options.connectToSortable).each(function () {\n        var i = t(this).sortable("instance");i && !i.options.disabled && (s.sortables.push(i), i.refreshPositions(), i._trigger("activate", e, n));\n      });\n    }, stop: function stop(e, i, s) {\n      var n = t.extend({}, i, { item: s.element });s.cancelHelperRemoval = !1, t.each(s.sortables, function () {\n        var t = this;t.isOver ? (t.isOver = 0, s.cancelHelperRemoval = !0, t.cancelHelperRemoval = !1, t._storedCSS = { position: t.placeholder.css("position"), top: t.placeholder.css("top"), left: t.placeholder.css("left") }, t._mouseStop(e), t.options.helper = t.options._helper) : (t.cancelHelperRemoval = !0, t._trigger("deactivate", e, n));\n      });\n    }, drag: function drag(e, i, s) {\n      t.each(s.sortables, function () {\n        var n = !1,\n            o = this;o.positionAbs = s.positionAbs, o.helperProportions = s.helperProportions, o.offset.click = s.offset.click, o._intersectsWith(o.containerCache) && (n = !0, t.each(s.sortables, function () {\n          return this.positionAbs = s.positionAbs, this.helperProportions = s.helperProportions, this.offset.click = s.offset.click, this !== o && this._intersectsWith(this.containerCache) && t.contains(o.element[0], this.element[0]) && (n = !1), n;\n        })), n ? (o.isOver || (o.isOver = 1, s._parent = i.helper.parent(), o.currentItem = i.helper.appendTo(o.element).data("ui-sortable-item", !0), o.options._helper = o.options.helper, o.options.helper = function () {\n          return i.helper[0];\n        }, e.target = o.currentItem[0], o._mouseCapture(e, !0), o._mouseStart(e, !0, !0), o.offset.click.top = s.offset.click.top, o.offset.click.left = s.offset.click.left, o.offset.parent.left -= s.offset.parent.left - o.offset.parent.left, o.offset.parent.top -= s.offset.parent.top - o.offset.parent.top, s._trigger("toSortable", e), s.dropped = o.element, t.each(s.sortables, function () {\n          this.refreshPositions();\n        }), s.currentItem = s.element, o.fromOutside = s), o.currentItem && (o._mouseDrag(e), i.position = o.position)) : o.isOver && (o.isOver = 0, o.cancelHelperRemoval = !0, o.options._revert = o.options.revert, o.options.revert = !1, o._trigger("out", e, o._uiHash(o)), o._mouseStop(e, !0), o.options.revert = o.options._revert, o.options.helper = o.options._helper, o.placeholder && o.placeholder.remove(), i.helper.appendTo(s._parent), s._refreshOffsets(e), i.position = s._generatePosition(e, !0), s._trigger("fromSortable", e), s.dropped = !1, t.each(s.sortables, function () {\n          this.refreshPositions();\n        }));\n      });\n    } }), t.ui.plugin.add("draggable", "cursor", { start: function start(e, i, s) {\n      var n = t("body"),\n          o = s.options;n.css("cursor") && (o._cursor = n.css("cursor")), n.css("cursor", o.cursor);\n    }, stop: function stop(e, i, s) {\n      var n = s.options;n._cursor && t("body").css("cursor", n._cursor);\n    } }), t.ui.plugin.add("draggable", "opacity", { start: function start(e, i, s) {\n      var n = t(i.helper),\n          o = s.options;n.css("opacity") && (o._opacity = n.css("opacity")), n.css("opacity", o.opacity);\n    }, stop: function stop(e, i, s) {\n      var n = s.options;n._opacity && t(i.helper).css("opacity", n._opacity);\n    } }), t.ui.plugin.add("draggable", "scroll", { start: function start(t, e, i) {\n      i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset());\n    }, drag: function drag(e, i, s) {\n      var n = s.options,\n          o = !1,\n          a = s.scrollParentNotHidden[0],\n          r = s.document[0];a !== r && "HTML" !== a.tagName ? (n.axis && "x" === n.axis || (s.overflowOffset.top + a.offsetHeight - e.pageY < n.scrollSensitivity ? a.scrollTop = o = a.scrollTop + n.scrollSpeed : e.pageY - s.overflowOffset.top < n.scrollSensitivity && (a.scrollTop = o = a.scrollTop - n.scrollSpeed)), n.axis && "y" === n.axis || (s.overflowOffset.left + a.offsetWidth - e.pageX < n.scrollSensitivity ? a.scrollLeft = o = a.scrollLeft + n.scrollSpeed : e.pageX - s.overflowOffset.left < n.scrollSensitivity && (a.scrollLeft = o = a.scrollLeft - n.scrollSpeed))) : (n.axis && "x" === n.axis || (e.pageY - t(r).scrollTop() < n.scrollSensitivity ? o = t(r).scrollTop(t(r).scrollTop() - n.scrollSpeed) : t(window).height() - (e.pageY - t(r).scrollTop()) < n.scrollSensitivity && (o = t(r).scrollTop(t(r).scrollTop() + n.scrollSpeed))), n.axis && "y" === n.axis || (e.pageX - t(r).scrollLeft() < n.scrollSensitivity ? o = t(r).scrollLeft(t(r).scrollLeft() - n.scrollSpeed) : t(window).width() - (e.pageX - t(r).scrollLeft()) < n.scrollSensitivity && (o = t(r).scrollLeft(t(r).scrollLeft() + n.scrollSpeed)))), o !== !1 && t.ui.ddmanager && !n.dropBehaviour && t.ui.ddmanager.prepareOffsets(s, e);\n    } }), t.ui.plugin.add("draggable", "snap", { start: function start(e, i, s) {\n      var n = s.options;s.snapElements = [], t(n.snap.constructor !== String ? n.snap.items || ":data(ui-draggable)" : n.snap).each(function () {\n        var e = t(this),\n            i = e.offset();this !== s.element[0] && s.snapElements.push({ item: this, width: e.outerWidth(), height: e.outerHeight(), top: i.top, left: i.left });\n      });\n    }, drag: function drag(e, i, s) {\n      var n,\n          o,\n          a,\n          r,\n          l,\n          h,\n          c,\n          u,\n          d,\n          p,\n          f = s.options,\n          g = f.snapTolerance,\n          m = i.offset.left,\n          _ = m + s.helperProportions.width,\n          v = i.offset.top,\n          b = v + s.helperProportions.height;for (d = s.snapElements.length - 1; d >= 0; d--) {\n        l = s.snapElements[d].left - s.margins.left, h = l + s.snapElements[d].width, c = s.snapElements[d].top - s.margins.top, u = c + s.snapElements[d].height, l - g > _ || m > h + g || c - g > b || v > u + g || !t.contains(s.snapElements[d].item.ownerDocument, s.snapElements[d].item) ? (s.snapElements[d].snapping && s.options.snap.release && s.options.snap.release.call(s.element, e, t.extend(s._uiHash(), { snapItem: s.snapElements[d].item })), s.snapElements[d].snapping = !1) : ("inner" !== f.snapMode && (n = g >= Math.abs(c - b), o = g >= Math.abs(u - v), a = g >= Math.abs(l - _), r = g >= Math.abs(h - m), n && (i.position.top = s._convertPositionTo("relative", { top: c - s.helperProportions.height, left: 0 }).top), o && (i.position.top = s._convertPositionTo("relative", { top: u, left: 0 }).top), a && (i.position.left = s._convertPositionTo("relative", { top: 0, left: l - s.helperProportions.width }).left), r && (i.position.left = s._convertPositionTo("relative", { top: 0, left: h }).left)), p = n || o || a || r, "outer" !== f.snapMode && (n = g >= Math.abs(c - v), o = g >= Math.abs(u - b), a = g >= Math.abs(l - m), r = g >= Math.abs(h - _), n && (i.position.top = s._convertPositionTo("relative", { top: c, left: 0 }).top), o && (i.position.top = s._convertPositionTo("relative", { top: u - s.helperProportions.height, left: 0 }).top), a && (i.position.left = s._convertPositionTo("relative", { top: 0, left: l }).left), r && (i.position.left = s._convertPositionTo("relative", { top: 0, left: h - s.helperProportions.width }).left)), !s.snapElements[d].snapping && (n || o || a || r || p) && s.options.snap.snap && s.options.snap.snap.call(s.element, e, t.extend(s._uiHash(), { snapItem: s.snapElements[d].item })), s.snapElements[d].snapping = n || o || a || r || p);\n      }\n    } }), t.ui.plugin.add("draggable", "stack", { start: function start(e, i, s) {\n      var n,\n          o = s.options,\n          a = t.makeArray(t(o.stack)).sort(function (e, i) {\n        return (parseInt(t(e).css("zIndex"), 10) || 0) - (parseInt(t(i).css("zIndex"), 10) || 0);\n      });a.length && (n = parseInt(t(a[0]).css("zIndex"), 10) || 0, t(a).each(function (e) {\n        t(this).css("zIndex", n + e);\n      }), this.css("zIndex", n + a.length));\n    } }), t.ui.plugin.add("draggable", "zIndex", { start: function start(e, i, s) {\n      var n = t(i.helper),\n          o = s.options;n.css("zIndex") && (o._zIndex = n.css("zIndex")), n.css("zIndex", o.zIndex);\n    }, stop: function stop(e, i, s) {\n      var n = s.options;n._zIndex && t(i.helper).css("zIndex", n._zIndex);\n    } }), t.ui.draggable, t.widget("ui.slider", t.ui.mouse, { version: "1.12.1", widgetEventPrefix: "slide", options: { animate: !1, classes: { "ui-slider": "ui-corner-all", "ui-slider-handle": "ui-corner-all", "ui-slider-range": "ui-corner-all ui-widget-header" }, distance: 0, max: 100, min: 0, orientation: "horizontal", range: !1, step: 1, value: 0, values: null, change: null, slide: null, start: null, stop: null }, numPages: 5, _create: function _create() {\n      this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1;\n    }, _refresh: function _refresh() {\n      this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();\n    }, _createHandles: function _createHandles() {\n      var e,\n          i,\n          s = this.options,\n          n = this.element.find(".ui-slider-handle"),\n          o = "<span tabindex=\'0\'></span>",\n          a = [];for (i = s.values && s.values.length || 1, n.length > i && (n.slice(i).remove(), n = n.slice(0, i)), e = n.length; i > e; e++) {\n        a.push(o);\n      }this.handles = n.add(t(a.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function (e) {\n        t(this).data("ui-slider-handle-index", e).attr("tabIndex", 0);\n      });\n    }, _createRange: function _createRange() {\n      var e = this.options;e.range ? (e.range === !0 && (e.values ? e.values.length && 2 !== e.values.length ? e.values = [e.values[0], e.values[0]] : t.isArray(e.values) && (e.values = e.values.slice(0)) : e.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({ left: "", bottom: "" })) : (this.range = t("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), ("min" === e.range || "max" === e.range) && this._addClass(this.range, "ui-slider-range-" + e.range)) : (this.range && this.range.remove(), this.range = null);\n    }, _setupEvents: function _setupEvents() {\n      this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles);\n    }, _destroy: function _destroy() {\n      this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy();\n    }, _mouseCapture: function _mouseCapture(e) {\n      var i,\n          s,\n          n,\n          o,\n          a,\n          r,\n          l,\n          h,\n          c = this,\n          u = this.options;return u.disabled ? !1 : (this.elementSize = { width: this.element.outerWidth(), height: this.element.outerHeight() }, this.elementOffset = this.element.offset(), i = { x: e.pageX, y: e.pageY }, s = this._normValueFromMouse(i), n = this._valueMax() - this._valueMin() + 1, this.handles.each(function (e) {\n        var i = Math.abs(s - c.values(e));(n > i || n === i && (e === c._lastChangedValue || c.values(e) === u.min)) && (n = i, o = t(this), a = e);\n      }), r = this._start(e, a), r === !1 ? !1 : (this._mouseSliding = !0, this._handleIndex = a, this._addClass(o, null, "ui-state-active"), o.trigger("focus"), l = o.offset(), h = !t(e.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = h ? { left: 0, top: 0 } : { left: e.pageX - l.left - o.width() / 2, top: e.pageY - l.top - o.height() / 2 - (parseInt(o.css("borderTopWidth"), 10) || 0) - (parseInt(o.css("borderBottomWidth"), 10) || 0) + (parseInt(o.css("marginTop"), 10) || 0) }, this.handles.hasClass("ui-state-hover") || this._slide(e, a, s), this._animateOff = !0, !0));\n    }, _mouseStart: function _mouseStart() {\n      return !0;\n    }, _mouseDrag: function _mouseDrag(t) {\n      var e = { x: t.pageX, y: t.pageY },\n          i = this._normValueFromMouse(e);return this._slide(t, this._handleIndex, i), !1;\n    }, _mouseStop: function _mouseStop(t) {\n      return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(t, this._handleIndex), this._change(t, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1;\n    }, _detectOrientation: function _detectOrientation() {\n      this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";\n    }, _normValueFromMouse: function _normValueFromMouse(t) {\n      var e, i, s, n, o;return "horizontal" === this.orientation ? (e = this.elementSize.width, i = t.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (e = this.elementSize.height, i = t.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), s = i / e, s > 1 && (s = 1), 0 > s && (s = 0), "vertical" === this.orientation && (s = 1 - s), n = this._valueMax() - this._valueMin(), o = this._valueMin() + s * n, this._trimAlignValue(o);\n    }, _uiHash: function _uiHash(t, e, i) {\n      var s = { handle: this.handles[t], handleIndex: t, value: void 0 !== e ? e : this.value() };return this._hasMultipleValues() && (s.value = void 0 !== e ? e : this.values(t), s.values = i || this.values()), s;\n    }, _hasMultipleValues: function _hasMultipleValues() {\n      return this.options.values && this.options.values.length;\n    }, _start: function _start(t, e) {\n      return this._trigger("start", t, this._uiHash(e));\n    }, _slide: function _slide(t, e, i) {\n      var s,\n          n,\n          o = this.value(),\n          a = this.values();this._hasMultipleValues() && (n = this.values(e ? 0 : 1), o = this.values(e), 2 === this.options.values.length && this.options.range === !0 && (i = 0 === e ? Math.min(n, i) : Math.max(n, i)), a[e] = i), i !== o && (s = this._trigger("slide", t, this._uiHash(e, i, a)), s !== !1 && (this._hasMultipleValues() ? this.values(e, i) : this.value(i)));\n    }, _stop: function _stop(t, e) {\n      this._trigger("stop", t, this._uiHash(e));\n    }, _change: function _change(t, e) {\n      this._keySliding || this._mouseSliding || (this._lastChangedValue = e, this._trigger("change", t, this._uiHash(e)));\n    }, value: function value(t) {\n      return arguments.length ? (this.options.value = this._trimAlignValue(t), this._refreshValue(), this._change(null, 0), void 0) : this._value();\n    }, values: function values(e, i) {\n      var s, n, o;if (arguments.length > 1) return this.options.values[e] = this._trimAlignValue(i), this._refreshValue(), this._change(null, e), void 0;if (!arguments.length) return this._values();if (!t.isArray(arguments[0])) return this._hasMultipleValues() ? this._values(e) : this.value();for (s = this.options.values, n = arguments[0], o = 0; s.length > o; o += 1) {\n        s[o] = this._trimAlignValue(n[o]), this._change(null, o);\n      }this._refreshValue();\n    }, _setOption: function _setOption(e, i) {\n      var s,\n          n = 0;switch ("range" === e && this.options.range === !0 && ("min" === i ? (this.options.value = this._values(0), this.options.values = null) : "max" === i && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), t.isArray(this.options.values) && (n = this.options.values.length), this._super(e, i), e) {case "orientation":\n          this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(i), this.handles.css("horizontal" === i ? "bottom" : "left", "");break;case "value":\n          this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;break;case "values":\n          for (this._animateOff = !0, this._refreshValue(), s = n - 1; s >= 0; s--) {\n            this._change(null, s);\n          }this._animateOff = !1;break;case "step":case "min":case "max":\n          this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;break;case "range":\n          this._animateOff = !0, this._refresh(), this._animateOff = !1;}\n    }, _setOptionDisabled: function _setOptionDisabled(t) {\n      this._super(t), this._toggleClass(null, "ui-state-disabled", !!t);\n    }, _value: function _value() {\n      var t = this.options.value;return t = this._trimAlignValue(t);\n    }, _values: function _values(t) {\n      var e, i, s;if (arguments.length) return e = this.options.values[t], e = this._trimAlignValue(e);if (this._hasMultipleValues()) {\n        for (i = this.options.values.slice(), s = 0; i.length > s; s += 1) {\n          i[s] = this._trimAlignValue(i[s]);\n        }return i;\n      }return [];\n    }, _trimAlignValue: function _trimAlignValue(t) {\n      if (this._valueMin() >= t) return this._valueMin();if (t >= this._valueMax()) return this._valueMax();var e = this.options.step > 0 ? this.options.step : 1,\n          i = (t - this._valueMin()) % e,\n          s = t - i;return 2 * Math.abs(i) >= e && (s += i > 0 ? e : -e), parseFloat(s.toFixed(5));\n    }, _calculateNewMax: function _calculateNewMax() {\n      var t = this.options.max,\n          e = this._valueMin(),\n          i = this.options.step,\n          s = Math.round((t - e) / i) * i;t = s + e, t > this.options.max && (t -= i), this.max = parseFloat(t.toFixed(this._precision()));\n    }, _precision: function _precision() {\n      var t = this._precisionOf(this.options.step);return null !== this.options.min && (t = Math.max(t, this._precisionOf(this.options.min))), t;\n    }, _precisionOf: function _precisionOf(t) {\n      var e = "" + t,\n          i = e.indexOf(".");return -1 === i ? 0 : e.length - i - 1;\n    }, _valueMin: function _valueMin() {\n      return this.options.min;\n    }, _valueMax: function _valueMax() {\n      return this.max;\n    }, _refreshRange: function _refreshRange(t) {\n      "vertical" === t && this.range.css({ width: "", left: "" }), "horizontal" === t && this.range.css({ height: "", bottom: "" });\n    }, _refreshValue: function _refreshValue() {\n      var e,\n          i,\n          s,\n          n,\n          o,\n          a = this.options.range,\n          r = this.options,\n          l = this,\n          h = this._animateOff ? !1 : r.animate,\n          c = {};this._hasMultipleValues() ? this.handles.each(function (s) {\n        i = 100 * ((l.values(s) - l._valueMin()) / (l._valueMax() - l._valueMin())), c["horizontal" === l.orientation ? "left" : "bottom"] = i + "%", t(this).stop(1, 1)[h ? "animate" : "css"](c, r.animate), l.options.range === !0 && ("horizontal" === l.orientation ? (0 === s && l.range.stop(1, 1)[h ? "animate" : "css"]({ left: i + "%" }, r.animate), 1 === s && l.range[h ? "animate" : "css"]({ width: i - e + "%" }, { queue: !1, duration: r.animate })) : (0 === s && l.range.stop(1, 1)[h ? "animate" : "css"]({ bottom: i + "%" }, r.animate), 1 === s && l.range[h ? "animate" : "css"]({ height: i - e + "%" }, { queue: !1, duration: r.animate }))), e = i;\n      }) : (s = this.value(), n = this._valueMin(), o = this._valueMax(), i = o !== n ? 100 * ((s - n) / (o - n)) : 0, c["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[h ? "animate" : "css"](c, r.animate), "min" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[h ? "animate" : "css"]({ width: i + "%" }, r.animate), "max" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[h ? "animate" : "css"]({ width: 100 - i + "%" }, r.animate), "min" === a && "vertical" === this.orientation && this.range.stop(1, 1)[h ? "animate" : "css"]({ height: i + "%" }, r.animate), "max" === a && "vertical" === this.orientation && this.range.stop(1, 1)[h ? "animate" : "css"]({ height: 100 - i + "%" }, r.animate));\n    }, _handleEvents: { keydown: function keydown(e) {\n        var i,\n            s,\n            n,\n            o,\n            a = t(e.target).data("ui-slider-handle-index");switch (e.keyCode) {case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:\n            if (e.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(t(e.target), null, "ui-state-active"), i = this._start(e, a), i === !1)) return;}switch (o = this.options.step, s = n = this._hasMultipleValues() ? this.values(a) : this.value(), e.keyCode) {case t.ui.keyCode.HOME:\n            n = this._valueMin();break;case t.ui.keyCode.END:\n            n = this._valueMax();break;case t.ui.keyCode.PAGE_UP:\n            n = this._trimAlignValue(s + (this._valueMax() - this._valueMin()) / this.numPages);break;case t.ui.keyCode.PAGE_DOWN:\n            n = this._trimAlignValue(s - (this._valueMax() - this._valueMin()) / this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:\n            if (s === this._valueMax()) return;n = this._trimAlignValue(s + o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:\n            if (s === this._valueMin()) return;n = this._trimAlignValue(s - o);}this._slide(e, a, n);\n      }, keyup: function keyup(e) {\n        var i = t(e.target).data("ui-slider-handle-index");this._keySliding && (this._keySliding = !1, this._stop(e, i), this._change(e, i), this._removeClass(t(e.target), null, "ui-state-active"));\n      } } });\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./dev/scripts/vendor/jquery-ui.min.js\n// module id = 597\n// module chunks = 0\n\n//# sourceURL=webpack:///./dev/scripts/vendor/jquery-ui.min.js?')},598:function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(jQuery) {\n\n/*!\n * jQuery UI Touch Punch 0.2.3\n *\n * Copyright 2011–2014, Dave Furfero\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n * Depends:\n *  jquery.ui.widget.js\n *  jquery.ui.mouse.js\n */\n(function ($) {\n\n  // Detect touch support\n  $.support.touch = 'ontouchend' in document;\n\n  // Ignore browsers without touch support\n  if (!$.support.touch) {\n    return;\n  }\n\n  var mouseProto = $.ui.mouse.prototype,\n      _mouseInit = mouseProto._mouseInit,\n      _mouseDestroy = mouseProto._mouseDestroy,\n      touchHandled;\n\n  /**\n   * Simulate a mouse event based on a corresponding touch event\n   * @param {Object} event A touch event\n   * @param {String} simulatedType The corresponding mouse event\n   */\n  function simulateMouseEvent(event, simulatedType) {\n\n    // Ignore multi-touch events\n    if (event.originalEvent.touches.length > 1) {\n      return;\n    }\n\n    event.preventDefault();\n\n    var touch = event.originalEvent.changedTouches[0],\n        simulatedEvent = document.createEvent('MouseEvents');\n\n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(simulatedType, // type\n    true, // bubbles                    \n    true, // cancelable                 \n    window, // view                       \n    1, // detail                     \n    touch.screenX, // screenX                    \n    touch.screenY, // screenY                    \n    touch.clientX, // clientX                    \n    touch.clientY, // clientY                    \n    false, // ctrlKey                    \n    false, // altKey                     \n    false, // shiftKey                   \n    false, // metaKey                    \n    0, // button                     \n    null // relatedTarget              \n    );\n\n    // Dispatch the simulated event to the target element\n    event.target.dispatchEvent(simulatedEvent);\n  }\n\n  /**\n   * Handle the jQuery UI widget's touchstart events\n   * @param {Object} event The widget element's touchstart event\n   */\n  mouseProto._touchStart = function (event) {\n\n    var self = this;\n\n    // Ignore the event if another widget is already being handled\n    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {\n      return;\n    }\n\n    // Set the flag to prevent other widgets from inheriting the touch event\n    touchHandled = true;\n\n    // Track movement to determine if interaction was a click\n    self._touchMoved = false;\n\n    // Simulate the mouseover event\n    simulateMouseEvent(event, 'mouseover');\n\n    // Simulate the mousemove event\n    simulateMouseEvent(event, 'mousemove');\n\n    // Simulate the mousedown event\n    simulateMouseEvent(event, 'mousedown');\n  };\n\n  /**\n   * Handle the jQuery UI widget's touchmove events\n   * @param {Object} event The document's touchmove event\n   */\n  mouseProto._touchMove = function (event) {\n\n    // Ignore event if not handled\n    if (!touchHandled) {\n      return;\n    }\n\n    // Interaction was not a click\n    this._touchMoved = true;\n\n    // Simulate the mousemove event\n    simulateMouseEvent(event, 'mousemove');\n  };\n\n  /**\n   * Handle the jQuery UI widget's touchend events\n   * @param {Object} event The document's touchend event\n   */\n  mouseProto._touchEnd = function (event) {\n\n    // Ignore event if not handled\n    if (!touchHandled) {\n      return;\n    }\n\n    // Simulate the mouseup event\n    simulateMouseEvent(event, 'mouseup');\n\n    // Simulate the mouseout event\n    simulateMouseEvent(event, 'mouseout');\n\n    // If the touch interaction did not move, it should trigger a click\n    if (!this._touchMoved) {\n\n      // Simulate the click event\n      simulateMouseEvent(event, 'click');\n    }\n\n    // Unset the flag to allow other widgets to inherit the touch event\n    touchHandled = false;\n  };\n\n  /**\n   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.\n   * This method extends the widget with bound touch event handlers that\n   * translate touch events to mouse events and pass them to the widget's\n   * original mouse event handling methods.\n   */\n  mouseProto._mouseInit = function () {\n\n    var self = this;\n\n    // Delegate the touch handlers to the widget's element\n    self.element.bind({\n      touchstart: $.proxy(self, '_touchStart'),\n      touchmove: $.proxy(self, '_touchMove'),\n      touchend: $.proxy(self, '_touchEnd')\n    });\n\n    // Call the original $.ui.mouse init method\n    _mouseInit.call(self);\n  };\n\n  /**\n   * Remove the touch event handlers\n   */\n  mouseProto._mouseDestroy = function () {\n\n    var self = this;\n\n    // Delegate the touch handlers to the widget's element\n    self.element.unbind({\n      touchstart: $.proxy(self, '_touchStart'),\n      touchmove: $.proxy(self, '_touchMove'),\n      touchend: $.proxy(self, '_touchEnd')\n    });\n\n    // Call the original $.ui.mouse destroy method\n    _mouseDestroy.call(self);\n  };\n})(jQuery);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./dev/scripts/vendor/jquery.ui.touch-punch.js\n// module id = 598\n// module chunks = 0\n\n//# sourceURL=webpack:///./dev/scripts/vendor/jquery.ui.touch-punch.js?")}});